<script type="text/javascript">


/**
 * https://leetcode.com/problems/add-digits/
 * @param {number} num
 * @return {number}
 * digit root
 * dn = 1 + (n - 1) % 9
 */
//

var addDigits = function(num) {
    return 1 + (num - 1) % 9
};

/**
 * https://leetcode.com/problems/plus-one/description/
 * @param {number[]} digits
 * @return {number[]}
 * 用一个数组表示一个整数，对这个整数加1，然后返回加之后的数组
 */
/**
 * @param {number[]} digits
 * @return {number[]}
 * 用一个数组表示一个整数，对这个整数加1，然后返回加之后的数组
 */
var plusOne = function(digits) {
    // 999 899
    var result = '', c = 1
    var resultArr = []
    while(digits.length) {
        c = digits.pop() + c
        result = c % 10 + result
        c = c > 9
    }
    
    if(c == 1) {
        result = "1" + result //"1234"
    }
    
    for(var i = 0; i < result.length; i++) {
        resultArr.push(+result.charAt(i))
    }
    
    return resultArr
};


/**
 * @param {number[]} nums
 * @return {number}
 * https://leetcode.com/submissions/detail/129272498/
 */
var findMaxConsecutiveOnes = function(nums) {
    //当前连续数量
    var curKeep = 0
    //历史连续数量
    var hisKeep = 0
    
    var result = 0
    for(var i = 0; i < nums.length; i++) {
        if(nums[i] == 1) {
            curKeep ++
            if(curKeep > hisKeep) {
                hisKeep = curKeep
            }
        } else {
            curKeep = 0
        }
        
        //result = (nums[i] == 1) ? result ++ : 0
    }
    
    return hisKeep
};


/**
 * @param {number} n
 * @return {string[]}
 * https://leetcode.com/problems/fizz-buzz/description/
 */
var fizzBuzz = function(n) {
    var arr = []
    for(var i = 1; i <= n; i++) {
        var result = ""
        if(i % 3 == 0) {
            result += "Fizz" 
        } 
        if(i % 5 == 0) {
            result += "Buzz"
        }
        
        arr.push(result || i + "")
    }
    
    return arr
};

/**
 * @param {number} num
 * @return {string}
 * https://leetcode.com/problems/base-7/description/
 */
var convertToBase7 = function(num) {
    var res = ""
    var n = 0
    var flag = num > 0 ? 1 : -1
    if(num == 0) {
        res = "0"    
    }
    
    num *= flag
    
    while(num != 0) {
        
        n = num % 7
        num = (num - n) / 7
        res = n + res
    }
    
    res = flag * (+res) + "" 
    console.log(typeof res)
    
    return res
};

/**
 * @param {number[]} nums
 * @return {number}
 * https://leetcode.com/submissions/detail/129342000/
 */
var singleNumber = function(nums) {
    var result = nums[0]
    for(var i = 0; i < nums.length; i++) {
        result = result ^ nums[i + 1]
    }
    
    return result
};


/**
 * @param {function} isBadVersion()
 * @return {function}
 * https://leetcode.com/problems/first-bad-version/description/
 */
var solution = function(isBadVersion) {

    //二分法
    return function(n) {
        var start = 1
          , end = n
        while (start <= end) {
            mid = parseInt(start + (end - start) / 2)
            if (!isBadVersion(mid)) {
                start = mid + 1
            } else if (isBadVersion(mid) && !isBadVersion(mid - 1)) {
                return mid
            } else {
                end = mid - 1
            }
        }
    };
};

/**
 * @param {number} n
 * @return {boolean}
 *  https://leetcode.com/problems/happy-number/description/
 */
/**
 * @param {number} n
 * @return {boolean}
 * https://leetcode.com/problems/happy-number/description/
 */
var isHappy = function(n) {
    //用一个数组将所有产生的数，进来的时候先判断数组里是否有这个数
    var met = []
    while(n != 1) {
        n = sum(n)
        
        if(met[n] != undefined) {
            return false
        }
        
        met[n] = n
    }
    return true
};

//给定一个整数n，求n每个位上所有数字平方的sum，返回这个sum
var sum = function(n) {
    var result = 0
    while(n != 0) {
        var tmp = 0
        tmp = n % 10
        result += tmp * tmp
        n = (n - tmp) / 10
    }
    return result
}

/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
    var position = [0, 0]
    // {index, +-1}
    var rlud = {
        "R": {
            "index": 0,
            "dir": 1
        },
        "L": {
            "index": 0,
            "dir": -1
        },
        "U": {
            "index": 1,
            "dir": 1
        },
        "D": {
            "index": 1,
            "dir": -1
        },
    }
    
    for(var i = 0; i < moves.length; i++) {
        position[rlud[moves[i]]["index"]] += rlud[moves[i]]["dir"]
    }
    
    if(position[0] == 0 && position[1] == 0) {
        return true
    }
    return false
};

//交换两个变量的值
//a  = a ^ b
//b = a ^ b
//a = a ^ b

//判断n是否为某个数的平方
var isPowerOfTwo = function(n) {
    var start = 0, end = n
    
    while(start <= end) {
        mid = parseInt(start + (end - start) / 2)
        if(mid * mid == n) {
            return true
        } else if(mid * mid < n) {
            start = mid + 1
        } else {
            end = mid - 1
        }
    }
    return false
};

/**
 * @param {number} n
 * @return {boolean}
 * https://leetcode.com/problems/power-of-two/description/
 * 判断n是否为2的幂
 * 2的x次幂，表示为2进制数为100...00
 * 那么 n & (n - 1)一定为0
 */
var isPowerOfTwo = function(n) {
    return n > 0 && (n & n - 1) === 0
};

//web 
/**
 * @param {number} n
 * @return {boolean}
 * loga b=logc b/logc a (a>0且a≠0,c>0且c≠1,b>0) 
 * 用换底公式？
 */
var isPowerOfTwo = function(n) {
    return Number.isInteger(Math.log(n/4)/Math.log(2));
};

//写一个程序，统计自身用了多少字符


/*
https://leetcode.com/problems/excel-sheet-column-title/description/
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 

   1 -> A  27 -> AA
   2 -> B  28 -> AB
   3 -> C  29 -> AC
   ...
   26 -> Z 52 -> AZ

 @param {number} n //52 AZ
 @return {string}  
 
*/
/* 1 -> A 27 -> AA   53 -> BA
   2 -> B 28 -> AB   54 -> BB
   3 -> C 29 -> AC   55 -> BC
   ...
   26 -> Z 52 -> AZ  78 -> BZ

*/

/* 1 -> A 27 -> AA   53 -> BA
   2 -> B 28 -> AB   54 -> BB
   3 -> C 29 -> AC   55 -> BC
   ...
   26 -> Z 52 -> AZ  78 -> BZ

*/

var convertToTitle = function(n) {
    var digits = ['A', 'B', 'C', 'D', 'E', 'F', 'G',
                  'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 
                  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 
                  'W', 'X', 'Y', 'Z']
    var result = ""
    var rem = 0 //记录每次对26取模的余数

    while(n) {
        rem = n % 26
        if(rem == 0) {
            result = "Z" + result
            n = (n - rem) / 26 - 1
        } else {
            result = digits[rem - 1] + result
            n = (n - rem) / 26
        }
    }

    return result
    
};
convertToTitle(26)
convertToTitle(51)
convertToTitle(52)
convertToTitle(80)
convertToTitle(676)
convertToTitle(702)
convertToTitle(705)
//52 AZ 27 AA 28 AB
convertToTitle(52)

/*
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.
*/

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    
};

/*
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example:
For num = 5 you should return [0,1,1,2,1,2].

Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
*/
/**
 * @param {number} num
 * @return {number[]}
 */
 /*-----Version 1--------*/
var countBits = function(num) {
    var number = new Array(num + 1)
    for(var i = 0; i <= num; i++) {
        number[i] = count1s(i)
    }

    return number
};

function count1s(n) {
    var count = 0, digit = 0
    while(n) {
        digit = n % 2
        n = (n - digit) / 2
        if(digit) {
            count ++
        }
    }
    return count
}

/*-----Version 2 A better way 归纳法--------*/

var countBits = function(num) {
    var number = new Array(num + 1)
    number[0] = 0
    var next_two_power = 1
    var prev_two_power
    if(num == 0) {
        return number
    } 
    
    for(var i = 1; i <= num; i++) {
        if(i == next_two_power) {
            number[i] = 1
            prev_two_power = next_two_power
            next_two_power *= 2
        } else {
            // i - prev_two_power 用于计算当前元素到上一个2的幂的距离
            // 这个距离也就等于第一个2的幂到0的距离 
            // 这道题的关键在于0-3 4-7 8-15 之间，都是上一组数包含1的个数，再加1
            number[i] = number[i - prev_two_power] + 1
        }
    }
    return number
};

/*
 * https://leetcode.com/problems/power-of-two/description/
 * Given an integer, write a function to determine if it is a power of two.
 * @param {number} n
 * @return {boolean}
 * 判断n是否为2的幂
 * 2的x次幂，表示为2进制数为100...00
 * 那么 n & (n - 1)一定为0
 */
var isPowerOfTwo = function(n) {
    return n > 0 && (n & n - 1) === 0
};

/*
 https://leetcode.com/problems/power-of-four/description/
* Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example:
Given num = 16, return true. Given num = 5, return false.

Follow up: Could you solve it without loops/recursion?
* 
*  4 ** n =>  2 ** 2n == > 写成2进制表示，1 00..00， 1右边一定有偶数个0 
   如何判断1右边有偶数个0？  找一个数字magic(101010101010)，与num进行&运算
   如果结果为0，说明1右边有偶数个0
   另外，4的幂，一定是2的幂
   magic是形如 0b0101010101010的三十一位二进制数(因为题目给出的是32 bits整数)
 * @param {number} num
 * @return {boolean}
 */
/**
 * @param {number} num
 * @return {boolean} 715827882 转成二进制只有三十位？？？
 
 */
var isPowerOfFour = function(num) {
    // if((num > 0) && (num & (num - 1) === 0) && (num & 715827882) === 0) {
    //     return true
    // } 
    if(num > 0) {
        if((num & (num - 1)) === 0) {
            if((num & 715827882) === 0) {
                return true
            }
        }
    }
    
    return false
};


</script>